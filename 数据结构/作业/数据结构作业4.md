---
title: 数据结构第四次作业
categories:
- 数据结构
- 查找
- 作业
tags:
- 查找
- 二叉查找树
---

# 作业4    查找结构与排序方法

作业题目： BST 查找结构与折半查找方法的实现与实验比较要求编写程序实现 BST 存储结构的建立（插入）、删除、查找和排序算法；实现折半查找算法；比较 BST 查找与折半查找方法的时间性能。  

## 作业要求：

## 1.设计 BST 的左右链存储结构，并实现 BST 插入（建立）、删除、查找和排序算法。

### 实现1：BST插入（建立）

创建查找树函数：

```c
BST CreateBST (FILE*fp)//创建一个二叉查找树
{
    BSTnode* F=NULL;
    keytype key;
    records R;
    fscanf(fp,"%d ",&key);//读入一个记录
    while(key){  //假设key=0是输入结束标志
        a[number]=key;
        number++;
        R.key=key;
        R.other='\0';
        F=InsertBST(R, F, 1);//插入记录R
        fscanf(fp,"%d",&key);//读入下个记录
    }
    return F;
}
```

树节点插入函数：

```c
BST InsertBST(records R, BST F,int flag)//插入查找树节点
{
    if ( F ==NULL ) {
        F =(BST) malloc(sizeof (BSTnode));
        F->data = R;
        F->lchild = NULL;
        F->rchild = NULL;
    }else  if ( R.key < F->data.key )
        F->lchild=InsertBST( R , F->lchild,0);
    else  if ( R.key > F->data.key )
        F->rchild=InsertBST( R , F->rchild,0);
    return F;
}
```

### 实现2：树节点删除函数

删除最小元素函数：

```c
records  deletemin(BST F)//删除最小元素
{
    records tmp ;
    BST p ;
    if (F->lchild==NULL){//是最小元
        p = F ;
        tmp = F->data ;
        F = F->rchild ; //右链继承
        free(p) ;
        return tmp ;//返回该最小节点值
    }
    else//左子树不空，最小结点在左子树上
        return deletemin(F->lchild);//在左子树上递归地删除
}

```

删除节点函数：

```c
BST  DeleteB (keytype k,BST F)
{
    if ( F != NULL )
    {
        if ( k < F->data.key )
            F->lchild=DeleteB( k, F->lchild );
        else if (k > F->data.key)
            F->rchild=DeleteB(k, F->rchild);
        else
        { // k==F->data.key
            if (F->rchild == NULL)
                F = F->lchild;//右链继承,包括叶
            else if (F->lchild == NULL)
                F = F->rchild;//右链继承,包括叶
            else //有两棵子树
                F->data = deletemin(F->rchild);
        }
    }
    else return NULL;
    return F;
}
```

### 实现3：查找算法

```c
BSTnode * SearchBST( keytype  k, BST F )//递归查找操作
{
    BST p = F;
    if (p == NULL) {
        return p;
    } else {
        if (k == p->data.key) { //递归终止条件
            count++;
            return p;
        }
    }
    if ( k < p->data.key )
    {
        count++;
        return ( SearchBST ( k,  p->lchild ) ) ; //查找左子树
    }
    else
    {
        count++;
        return ( SearchBST ( k,  p->rchild ) ) ; //查找右子树
    }
```

### 实现4：排序算法（中序遍历）

```c
void visit(BST F)//中序遍历，形成有序序列
{
    if(F==NULL)return;
    visit(F->lchild);
    printf("%d ",F->data.key);
    Bin[number++]=F->data;
    visit(F->rchild);
}
```

## 2.实现折半查找算法

```c
int BinFind(const keytype k,int low,int high)//折半查找递归方法
{
    int temp;//储存中点位置下标
    if(low>high)return -1;
    else
    {
        int temp=(low+high)/2;
        if(k<Bin[temp].key)
        {
            count++;
            return BinFind(k,low,temp-1);
        }
        else if(k>Bin[temp].key)
        {
            count++;
            return BinFind(k,temp+1,high);
        }
        else
        {
            count++;
            return temp;
        }
    }
}
```

## 3.实验比较：设计并产生实验测试数据，考察比较两种查找方法的时间性能，并与理论结果进行比较。  

实验数据测试文件为:

```c
int main() {
    FILE*fp;
    BST F=NULL;
    BST answer=NULL;
    double average_length=0; fp=fopen("C:\\Users\\Slater\\Documents\\vscode\\.vscode\\DSAFE\\Chapter5 Search\\data.txt","r");
    F=CreateBST(fp);
    for(int i=0;i<number-1;i++)
    {
        SearchBST(a[i],F);
        sum=sum+count;
        count=0;
    }
    average_length=(double)(sum)/number;
    printf("查找树查找成功平均长度：%.2f\n",average_length);
    sum=0;
    for(int i=0;i<number-1;i++)
    {
        SearchBST(1234,F);
        sum=sum+count;
        count=0;
    }
    average_length=(double)(sum)/number;
    printf("查找树查找失败平均长度: %.2f\n",average_length);
    number=0;
    visit(F);
    printf("\n");
    sum=0;
    for(int i=0;i<number-1;i++) {
        BinFind(a[i],0,1023);
        sum = sum + count;
        count = 0;
    }
    average_length=(double)(sum)/number;
    printf("折半查找成功平均长度: %.2f\n",average_length);
    sum=0;
    for(int i=0;i<number-1;i++) {
        BinFind(1234,0,1023);
        sum = sum + count;
        count = 0;
    }
    average_length=(double)(sum)/number;
    printf("折半查找失败平均长度: %.2f",average_length);
//    F=DeleteB(5,F);
//    visit(F);
    return 0;
}
```

第一组实验数据：

> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 0

测试结果：

> 查找树查找成功平均长度：511.50
> 查找树查找失败平均长度: 1023.00
>
> 折半查找成功平均长度: 9.00
> 折半查找失败平均长度: 10.99

第一个测试用例是使用一个顺序序列组成的，产生的查找树为一个链式结构，发生了树的退化，所以查找成功平均长度和失败平均长度远比折半查找所需要的平均长度长，这是因为没有利用树的优良结构造成的，查找成功平均长度为n/2，失败平均长度为n。基本上符合理论值。

折半查找的方式比较稳定，始终维持在log2(n)左右。



第二组实验数据

> 101 320 326 197 282 454 409 479 242 412 998 878 368 628 525 1019 19 294 258 268 875 960 950 994 158 986 933 407 198 293 170 363 35 130 195 671 919 445 249 478 137 884 560 779 70 935 718 699 864 262 424 317 494 790 471 433 1014 405 350 302 217 640 214 922 16 927 297 896 147 715 569 911 140 438 805 322 945 62 751 307 398 413 434 789 52 121 95 305 161 988 502 653 524 820 636 421 304 681 394 324 578 240 1015 521 9 759 938 649 830 500 545 582 451 968 528 370 441 842 882 592 870 247 723 458 662 1 958 96 136 468 264 648 1002 618 53 129 1023 192 55 869 899 552 423 839 112 459 109 605 119 897 791 159 483 972 261 995 821 275 553 915 832 987 188 1001 542 290 455 829 23 713 737 174 349 746 152 902 144 546 917 799 1003 980 635 614 730 452 460 233 695 503 371 575 165 444 402 85 461 963 738 278 858 380 881 178 743 168 383 189 801 644 491 176 207 93 374 42 520 729 527 874 63 971 355 369 813 267 5 157 871 187 474 703 657 889 51 584 351 702 160 485 574 690 139 7 814 470 154 712 39 143 840 841 984 279 86 133 475 15 531 232 976 392 41 836 205 624 196 589 134 104 250 611 818 627 891 847 944 338 373 210 222 785 72 272 131 622 68 637 337 515 806 844 310 898 808 748 221 625 964 403 343 992 285 600 745 58 49 742 514 856 511 979 777 696 225 406 314 1004 556 245 1010 21 652 447 766 252 852 391 720 857 633 108 819 536 990 587 928 364 931 537 807 389 203 155 732 770 1007 594 94 876 825 1020 824 46 462 793 303 259 651 835 395 566 107 24 28 962 641 792 740 796 82 472 947 974 14 967 694 629 142 246 961 837 530 469 388 57 366 532 20 190 173 1024 125 827 66 544 758 346 686 774 646 34 577 220 555 559 88 620 342 512 83 492 1018 457 312 422 506 286 172 59 486 516 473 706 71 535 939 956 219 1017 655 691 708 77 345 940 775 568 672 798 359 700 32 563 518 348 811 701 951 182 654 230 688 47 803 645 872 265 356 379 923 647 495 965 711 501 861 110 227 186 429 476 727 548 69 634 399 997 602 561 123 667 204 65 914 942 226 586 79 381 43 642 621 604 595 122 623 498 724 177 573 128 704 141 1008 376 260 169 385 676 378 269 105 149 538 953 540 763 505 776 280 463 287 138 404 235 597 585 361 238 557 977 253 894 87 863 151 850 89 91 255 76 741 213 358 509 843 248 954 271 873 849 593 733 408 809 879 74 601 340 883 175 734 1000 179 613 679 273 446 432 291 435 769 739 115 772 661 352 436 489 308 218 867 256 411 193 40 333 277 900 854 100 321 683 558 660 283 44 301 184 975 916 354 428 606 632 113 295 762 336 386 710 716 111 721 722 859 215 905 541 969 619 831 216 1021 367 866 1016 335 274 135 263 749 966 257 437 692 773 323 98 529 92 996 771 551 377 957 25 783 812 102 266 127 901 1013 126 725 415 698 375 909 705 420 251 453 311 913 504 484 562 989 450 949 341 164 780 788 800 167 410 482 300 565 726 75 319 510 731 30 237 682 241 756 1009 761 417 56 439 306 1005 162 982 1006 918 29 132 426 853 296 946 549 834 396 907 50 539 78 616 567 18 517 677 229 608 508 8 610 171 414 925 674 120 936 116 680 786 202 362 156 329 817 937 599 223 166 973 390 33 425 26 993 591 948 617 795 554 313 309 607 707 254 684 234 183 339 360 787 895 581 910 48 650 289 719 760 631 736 90 828 754 669 236 685 893 668 929 580 892 3 325 201 794 757 384 181 522 985 678 1022 886 487 804 665 666 534 153 449 978 885 877 564 45 114 868 547 124 596 464 4 81 191 97 180 243 2 943 714 926 194 983 815 999 750 344 431 890 904 327 27 924 206 467 393 148 427 465 658 590 753 752 54 767 603 316 387 523 638 442 826 331 224 401 697 765 145 36 887 823 920 60 579 497 211 212 315 570 448 782 526 270 13 709 64 959 906 543 981 456 912 288 533 365 728 493 630 576 880 12 38 833 416 419 865 328 292 440 778 73 643 930 1011 481 209 903 353 588 298 664 418 583 768 276 970 490 932 860 330 118 851 11 781 382 332 693 84 572 334 67 717 496 99 744 670 845 231 659 1012 146 200 199 513 499 103 228 687 802 934 675 755 150 106 163 626 888 747 239 908 921 955 480 6 400 519 443 612 37 477 941 22 663 550 673 284 816 784 848 185 430 117 488 347 244 397 991 862 855 797 609 10 507 735 571 689 208 61 466 952 810 80 372 17 764 299 281 822 838 31 598 615 656 846 639 357 318 0

测试结果：

> 查找树查找成功平均长度：13.30
> 查找树查找失败平均长度: 8.99
>
> 折半查找成功平均长度: 9.00
> 折半查找失败平均长度: 10.99

第二个测试数据使用了随机数，产生的查找树的完成度很高，所以查找的过程中折半查找和查找树的平均长度基本相同，两者的性能基本相同，都为log2(n)左右。



## 测试后结论

经过测试，可以发现查找树和折半查找的性质基本相同，其原因为：在进行折半查找时的理论查找长度为log2(n)左右，而查找树的理论成功查找长度为log2(n)~n/2左右。所以最后分析出来时可以直观的感受到，当随机数分布的比较均匀时，查找树和折半查找的性能确实具有相似性。而当数据分布具有顺序而不是平均化的随机分布时，明显折半查找要优于查找树（未经平衡化）。