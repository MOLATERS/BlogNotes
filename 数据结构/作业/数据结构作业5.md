---
title: 数据结构第5次作业
categories: 
- 数据结构
- 排序
- 作业
tags:
- 树
- 二叉树
- 堆
- 排序
---
# 作业5  排序方法

## （1） 指出堆和二叉排序树的区别；  

> ​		在二叉排序树中，形状是不一定的，但是时刻满足每个节点的值均大于其左子树上所有结点的值，小于其右子树上所有结点的值。所以在左右子树之间的节点值不会有交叉的情况；满足了对这个树的中序遍历能够得到一个有序的序列。
>
> ​		堆是一个完全二叉树（无论在什么情况下），并且每个结点的值都大于或等于其左右结点的值（一个大根堆），所以堆石节点之间满足次序关系的二叉树，对堆的遍历无法形成一个有序的序列。
>
> ​		在树的形状上，排序二叉树的形状不定，深度在log(n)~n之间；而对于堆而言，深度对应的完全二叉树深度始终是log(n)。
>
> ​		在二叉排序树中，最小值结点是最左下结点，其左指针为空；最大值结点是最右下结点，其右指针为空。在大根堆中，最小值结点位于某个叶子结点，而最大值结点是大根堆的堆顶（即根结点）。
>
> ​		二叉排序树是为了实现动态查找而设计的数据结构，它是面向查找操作的，在二叉排序树中查找一个结点的平均时间复杂度是O(log n)；堆是为了实现排序而设计的一种数据结构，它不是面向查找操作的，因而在堆中查找一个结点需要进行遍历，其平均时间复杂度是O(n)。



## （2）若只想得到一个序列中第 k (k ≥ 5) 个最小元素之前的部分排序序列，则最好采用什么排序方法?  

> 最好采用堆排序
>
> 在基于比较的排序方法中，插入排序、快速排序和归并排序只有在所有元素都排完之后才能得到前k个最小序列，算法的效率不高。能够完成在第k趟排序之后就可以得到前k个最小的元素序列，因为在每一趟排序之中都可以确定一个最小的元素，但是采用堆排序效率最高。对于有n个元素的序列，建立初始堆的时间最多为4n，取得第k个最小元素之前的排序序列所花时间是klog2(n)(最坏情况)所以总时间为4n+klog2(n),而冒泡排序和选择排序每一次都要遍历，使用的时间是kn次，当k>=5的时候显然堆排序的计算式更小。所以堆排序的时间效率更优。



## 3） 已知由𝑛 (𝑛 ≥ 2) 个正整数构成的集合𝐴 = {𝑎: 0 ≤ 𝑘 < 𝑛}，将其划分为两个不相交的子集𝐴1和𝐴2，元素个数分别是𝑛1和𝑛2， 𝐴1和𝐴2中的元素之和分别为𝑆1和𝑆2。设计一个尽可能高效的划分算法，满足|𝑛1 - 𝑛2|最小且|𝑆1 - 𝑆2|最大。要求:

### 1)给出算法的基本设计思想；

> 题目分析：
>
> 满足|n1-n2|最小，|S1-S2|最大，表明是将最大的n/2个元素放入A2，最小的n/2的元素放入A1，类似于快速排序的分块思想，利用中枢点的思想来对这个集合进行划分。
>
> 设计思想：
>
> 按照快速排序方法的思想，使用的寻找中部数值的方式，在划分完之后判断中枢点是否在n/2的位置上，如果中枢点位置k>n/2那么表示对A2部分的划分完成，再在A1段选择中枢，对A1进行划分，划分完之后再判断新中枢与n/2的关系，划分出来的新区域与A2进行合并。同理，当k<n/2时进行上述相反的操作，最后使得结果满足要求。



### 2)根据设计思想，采用 C/C++语言描述算法，关键之处给出注释；

核心代码：

```c
int Separate(int a[MAX],int n)
{
    int pivot;//中枢位置值
    int k;//中枢位置下标
    int pivotindex;//选择新的中枢位置下标
    pivotindex= FindPivot(0,n-1,a);
    k= Partition(0,n-1,pivot,a);
 	while(k!=n/2)//不断进行迭代直到中枢下标为n/2
    {
        if(k<n/2)
        {
            pivotindex= FindPivot(k,n-1,a);
            pivot=a[pivotindex];
            k= Partition(k,n-1,pivot,a);
        }
        else if(k>n/2)
        {
            pivotindex= FindPivot(0,k-1,a);
            pivot=a[pivotindex];
            k= Partition(0,k-1,pivot,a);
        }
    }
}
```

设计代码：

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define MAX 100

int swap(int* A,int* B);
int Partition ( int i , int j , int pivot,int a[MAX]);
int FindPivot( int  i, int  j,int a[MAX]);
int Separate(int a[MAX],int n);
int show(int a[MAX],int n);

int main() {
    srand(time(0));
    int flag[MAX]={0};
    int count=0;
    int a[MAX]={0};
    while(count<20)
        {
            a[count]=rand()%100;
            if(flag[a[count]]!=1)
            {
                flag[a[count]]=1;
                count++;
            }
        }
    show(a,count);
    Separate(a,count);
    show(a,count);
    return 0;
}

int show(int a[MAX],int n)
{
    for(int i=0;i<=n-1;i++)
    {
        if(i==n/2-1)
            printf("%d || ",a[i]);
        else
        printf("%d ",a[i]);
    }
    printf("\n");
}

int  FindPivot( int  i, int  j,int a[MAX])        /* 设A是外部数组 */
{
    int firstkey = a[i] ; /* 第1个关键字的值A[i].key */
    int  k;                                       /* 从左到右查找不同的关键字 */
    for ( k=i+1 ;  k<=j; k++ )         /* 扫描不同的关键字 */
        if ( a[k] > firstkey )   /* 选择较大的关键字 */
            return  k ;
        else if ( a[k] < firstkey )
            return  i ;
    return  0 ;
}

int Partition ( int i , int j , int pivot,int a[MAX])
{
    int l = i, r = j ;
    do{
        while ( a[r]>=pivot )  r--;
        while ( a[l]< pivot  )  l++;
        if( l < r ) swap(&a[l],&a[r]);
    } while( l <= r );
    return l ;
}

int swap(int* A,int* B)
{
    int temp=*A;
    *A=*B;
    *B=temp;
}

int Separate(int a[MAX],int n)
{
    int pivot;
    int k;
    int pivotindex;
    pivotindex= FindPivot(0,n-1,a);
    k= Partition(0,n-1,pivot,a);
    while(k!=n/2)
    {
        if(k<n/2)
        {
            pivotindex= FindPivot(k,n-1,a);
            pivot=a[pivotindex];
            k= Partition(k+1,n-1,pivot,a);
        }
        else if(k>n/2)
        {
            pivotindex= FindPivot(0,k,a);
            pivot=a[pivotindex];
            k= Partition(0,k-1,pivot,a);
        }
    }

}


```



测试数据结果：

> 测试用例：（十次）
>
> 1. 进行分组之前：76 59 89 75 67 53 57 0 49 16 || 10 50 69 99 54 64 55 40 34 82 
>    进行分组之后：34 10 40 16 50 53 49 0 54 55 || 57 67 69 75 59 64 99 89 76 82 
>
> 2. 进行分组之前：47 48 85 80 12 5 95 35 56 31 || 19 72 70 30 54 27 11 42 37 51 
>    进行分组之后：19 37 42 11 12 5 27 35 30 31 || 47 72 70 56 54 95 80 85 48 51 
> 3. 进行分组之前：7 32 93 34 38 33 71 92 88 77 || 65 8 53 89 11 43 66 31 56 81 
>    进行分组之后：7 8 11 31 32 33 34 38 53 43 || 65 56 71 77 66 89 88 81 93 92 
> 4. 进行分组之前：7 32 93 34 38 33 71 92 88 77 || 65 8 53 89 11 43 66 31 56 81 
>    进行分组之后：7 8 11 31 32 33 34 38 53 43 || 65 56 71 77 66 89 88 81 93 92 
> 5. 进行分组之前：9 52 26 33 10 64 15 30 63 5 92 42 56 78 79 || 69 59 34 45 89 0 47 49 66 88 12 60 24 84 29 
>    进行分组之后：9 0 26 5 10 24 15 12 30 29 34 42 47 33 45 || 49 59 69 79 89 78 56 92 66 88 63 60 64 84 52 
> 6. 进行分组之前：3 76 67 41 20 35 72 75 79 52 78 80 44 62 69 12 82 22 33 8 15 49 74 61 17 63 9 11 85 14 || 68 89 71 81 86 59 43 39 50 97 54 87 38 32 66 7 37 84 45 5 1 2 26 64 95 77 36 21 13 27 
>    进行分组之后：1 2 3 5 7 8 9 11 12 13 14 15 17 20 21 22 26 27 32 33 35 37 36 38 39 41 43 45 44 49 || 50 54 52 61 59 63 62 67 71 68 72 75 74 69 66 64 87 84 97 86 81 89 85 82 95 77 80 78 79 76 
> 7. 进行分组之前：82 62 24 36 94 72 35 42 38 53 77 23 76 68 92 8 65 83 58 61 34 75 26 41 78 17 50 30 98 47 || 80 6 71 73 11 32 39 9 10 27 51 31 4 60 91 15 22 95 88 55 33 99 18 84 44 19 46 20 28 45 
>    进行分组之后：4 8 9 6 10 32 19 30 31 27 18 23 22 15 20 28 17 11 24 26 33 34 38 35 36 39 41 42 44 45 || 46 47 51 53 50 60 61 58 55 73 71 80 78 75 65 68 76 77 72 62 88 99 95 84 91 98 83 92 94 82 
> 8. 进行分组之前：41 25 99 92 48 17 23 1 38 77 91 70 39 98 43 66 12 68 18 32 47 82 84 83 14 79 72 35 0 9 || 97 78 16 94 96 90 42 7 53 19 74 10 56 36 49 46 3 52 69 59 34 55 15 57 45 44 85 29 4 30 
>    进行分组之后：0 1 3 4 7 9 10 12 14 15 16 17 18 19 23 25 29 30 32 34 35 36 38 39 41 42 45 44 43 46 || 47 49 52 48 53 55 57 56 66 68 59 77 74 70 78 72 69 82 79 91 98 90 96 94 97 84 85 92 99 83 
> 9. 进行分组之前：61 0 13 99 72 66 12 64 43 74 18 77 20 53 15 38 45 69 95 22 90 4 82 76 75 97 10 83 7 88 || 65 35 52 80 98 62 33 59 8 11 60 63 68 37 93 50 54 31 3 86 26 48 89 27 84 71 78 5 32 57 
>    进行分组之后：7 0 13 32 5 27 12 33 10 26 18 3 20 8 15 11 4 31 22 35 50 45 37 52 38 53 43 48 54 57 || 59 60 65 80 98 62 88 83 97 75 76 63 68 82 93 90 95 69 77 86 74 64 89 66 84 71 78 72 99 61 
> 10. 进行分组之前：79 27 63 42 48 57 56 86 36 20 93 85 45 38 95 46 39 83 96 76 94 23 82 44 73 40 81 90 11 22 || 91 74 18 77 7 71 21 33 16 28 78 68 47 34 72 51 69 50 25 35 17 49 12 15 54 4 14 6 9 67 
>     进行分组之后：25 15 21 22 11 16 7 9 17 20 6 14 23 12 4 18 27 28 35 33 38 36 34 39 42 40 44 45 46 47 || 48 49 51 54 56 57 63 50 71 77 78 68 74 73 72 76 69 67 91 90 81 82 94 96 83 95 85 93 86 79 



### 3)说明你所设计算法的平均时间复杂度和空间复杂度。  

算法的时间复杂度考虑在最外层循环最坏情况时log(n)次，函数内部的使用的复杂度为O(n), 所以最后整个算法的时间复杂度为O(nlogn)。

未使用函数的递归调用，空间复杂度为O(1)。