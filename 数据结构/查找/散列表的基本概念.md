---
title: 散列表
categories:
- 数据结构
- 查找
- 笔记
tags:
- 散列表
- 排序
mathjex: true
---
<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# 散列表

## 散列表的基本概念

在线性表和树表中，查找的方法建立在“比较”的基础上，查找的效率取决于比较的次数。

**散列函数：**一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr(这里的地址可以是数组下标、索引或者内存地址等)。

**冲突：**散列函数会将两个及以上的不同关键字映射到同一个地址，称这种情况为冲突；另一方面，由于这样的冲突总是不可避免的，所以还要设计处理冲突的方法。

**散列表：**根据关键字而直接进行访问的数据结构。也就是说，**散列表建立了关键字与存储地址之间的一种直接映射的关系**。

理想情况下，对散列表进行查找进行查找的时间复杂度为O（1），与表中的元素个数无关。下面分别介绍常用的散列函数和处理冲突的方法。



## 散列函数的构造方法

在构造散列函数时注意：

1. 散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或者地址范围。
2. 散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生。
3. 散列函数应尽量简单，能够在较短的时间内计算出任一关键字对应的散列地址。

下面介绍常用的散列函数

- 直接定址法

  直接取关键字的某个线性函数值为散列地址，散列函数为：
  $$
  H(key)=key或H(key)=a\times key+b
  $$
  式中，a和b是常数。这种方式计算最简单，且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。

- 除留余数法

  这是一种最简单、最常用的方法，假定散列表长为m，取一个不大于m但是最接近或者等于m的指数p,利用以下公式把关键字转换为散列地址。散列函数为：
  $$
  H(key)=key(mod(p))
  $$
  除留余数法的关键是选好p, 使得每个关键字通过该过该函数转换后等概率地映射到散列空间上的任意一个地址，从而尽可能减少冲突的可能性。

- 数字分析法

  设关键字数r进制数，而r个数码在各位出现的频率不同。选取数码分布均匀的若干位作为散列地址。这种方法适用于已知关键字集合，若更换了关键字，则需要重新构造新的散列函数。

- 平方取中法

  顾名思义，这种方法取关键字的平方值的中间几位作为散列地址。具体取多少位要看实际情况而定。这种方法得到的散列地址与关键字每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。



## 处理冲突的方法

- 开放定址法

  可存放新表项的空闲地址既向它的同义词表项开放，又同它的非同义词表项开放。其数学递推公式为
  $$
  H_i=(H(key)+d_i)\%m
  $$
  式子中H（key）为散列函数：i=0,1,2,……，k($k\leq m-1$);

  1. 线性探测法。当$d_i=0,1,2,……，m-1$时，称为**线性探测法**。这种方法的特点是：冲突发生时，顺序查看表的下一个单元，直到找到一个空闲单元或者查遍全表。线性探测法可能会导致堆积，降低了查找效率。

  2. 平方探测法。当$d_i=0^2,1^2,-1^2,……，k^2,-k^2$,称为**平方探测法**。其中$k\leq m/2$散列表长度必须是一个可以表示称4k+3的素数，又称二次探测法。缺点是不饿能探测到散列表中的所有单元。

  3. 双散列表。当$d_i=Hash_2(key)$时，称为双散列法。需要使用两个散列函数，H(key)得到的地址发生冲突时，则利用第二个散列函数$Hash_2(key)$计算该关键字的地址增量。它的具体散列函数形式如下：$H_i=(H(key)+i\times Hash_2(key))\%m$ 初始探测位置$H_0=H(key)\%m$i是冲突的次数，初始值是0。

- 拉链法

  可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。



## 散列查找及性能分析

散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字key, 根据散列函数可以计算出散列地址，执行步骤为：

- 初始化：Addr=Hash(key);
  1. 检测查找表中地址为Addr的位置上是否有记录，若没有记录，返回查找失败，若有记录，比较key值，若相等，就返回查找成功标志，执行2
  2. 用给定的处理冲突的方式计算下一个散列地址，并把Addr设置为此地址，转为步骤1

对同一组关键字，设定相同的散列函数，则不同的处理冲突的方法得到的散列表不同，它们的平均查找长度也不同。

从散列表的查找过程可见：

1. 需要以平均查找长度作为衡量散列表的查找效率的度量。

2. 散列表的查找效率取决于三个因素：散列函数、处理冲突方法和装填因子

   **装填因子**：散列表的装填因子一般记为$\alpha$定义一个表的装满程度，即：
   $$
   \alpha=\frac{表中记录数n}{散列表长度m}
   $$
   散列表的平均查找长度依赖于散列表的装填因子$\alpha$，而不直接依赖于n或者m。$\alpha$越大，能装填的记录越满，发生冲突的可能性就更大。
