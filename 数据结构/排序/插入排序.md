---
title: 插入排序
categories:
- 数据结构
- 排序
- 笔记
tags:
- 排序
mathjex: true
---
<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# 插入排序

## 直接插入排序

假设在排序过程中,待排序表L[1...i-1]在某次排序过程的某个时刻的状态,要将L(i)插入已有序的子序列中,需要执行以下操作:

1. 查找出L(i)在L[1...i-1]中的插入位置k
2. 将L[k...i-1]中的所有元素依次向后移动一个位置.
3. 将L(i)复制到L(k).

为了实现对L[1...n]的排序,可以将L(2)~L(n)依次插入前面已经排好序的子序列,初始L[1]可以视为是一个已经排好序的子序列.上述执行n-1次就能得到一个有序的表

```c
void InsertSort(ElemType A[],int n){
	int i,j;
	for(i=2;i<=n;i++)//依次将A[2]~A[n]插入前面已经排序的序列
	{//若A[i]关键码小于其前驱,将A[i]插入有序表
		if(A[i]<A[i-1]){//复制为哨兵,A[0]不存放元素
		A[0]=A[i];
		for(j=i-1;A[0]<A[j];--j)//从后往前查找待插入位置
			A[j+1]=A[j];//向后挪位
		A[j+1]=A[0];//复制到插入位置
		}
	}
}
```

空间效率:$O(1)$

时间效率:$O(n^2)$

稳定性:稳定的排序方法

适用性:顺序存储和链式存储的线性表



## 折半插入排序

可以对查找进行优化,使用折半查找法:

```c
void InsertSort(ElemType A[], int n)
{
	int i,j,low,high,mid;
	for(i=2;i<=n;i++)//依次将A[2]~A[n]插入前面的已排序序列
	{
		A[0]=A[i];//将A[i]暂存到A[0]
		low=1;high=i-1;//数值折半查找的范围
		while(low<=high){//折半查找(默认递增有序)
			mid=(low+high)/2;//取中间点
			if(A[mid]>A[0])high=mid-1;//查找左半子表
			else low=mid-1;//查找右半子表
		}
		for(j=i-1;j>=high+1;--j)
		A[j+1]=A[j];
		A[high+1]=A[0];
	}
}
```

从上述算法中,不难看出折半插入排序仅减少了比较元素的次数,约为$O(nlog_2(n))$,比较次数与待排序表的初始状态无关，仅取决于表中的元素个数n,而元素的移动次数并未改变，它依赖于待排序表的初始状态。因此，折半插入排序的时间复杂度仍为$O(n^2)$,但是对于数据量不是很大的排序表，折半插入排序往往能表现出很好的性能。



## 希尔排序

直接插入排序算法的时间复杂度为$O(n^2)$,如果排列顺序为“正序”时，其时间复杂度可以提高至$O(n)$。希尔排序正是利用了这些优点对插入排序改进之后得来，称为，**缩小增量排序**。

希尔排序的基本思想是：先将待排序表分割成若干形如$L[i,i+d,i+2d,……,i+kd]$的特殊子表，即把相隔某个增量的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。

希尔排序的过程：

1. 取一个小于n的步长$d_1$,把表中的全部记录分成$d_1$组，所有距离为$d_1$倍数的记录放在同一组，在各组内进行直接插入排序
2. 然后取第二个步长$d_2<d_1$,重复上述过程，直到$d_1=1$所有记录已放在同一组中，在进行直接插入排序，由于此时已经有了较好的局部有序性，所以能很快得到结果。

```c
void ShellSort(ElemType A[], int n)
{//A[0]作为暂存单元
	for(dk=n/2;dk>=1;dk=dk/2)
	{
		for(i=dk+1;i<=n;++i)
		{
			if(A[i]<A[i-dk]){//需要将A[i]插入有序增量子表
				A[0]=A[i];//暂存在A[0]
				for(j=i-dk;j>0&&A[0]<A[j];j-=dk)
					A[j+dk]=A[j];//记录后移，查找插入的位置
				A[j+dk]=A[0];//插入
			}
		}
	}
}
```

性能分析：

空间效率：$O(1)$

时间效率：当n在某个特定的范围内时复杂度为$O(n^{1.3})$,最坏情况为$O(n^2)$

稳定性：当相同关键字被划分到不同的子表时，可能会改变它们之间的相对次序，因此是一个不稳定的排序方法。

实用性：希尔排序算法只适用于顺序存储。