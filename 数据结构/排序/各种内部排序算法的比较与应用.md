---
title: 各种内部排序算法的比较与应用
categories:
- 数据结构
- 排序
- 笔记
tags:
- 排序
mathjex: true
---
<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# 各种内部排序算法的比较与应用

## 内部排序算法的比较

基于三个因素来进行对比

**时空复杂度**，**算法的稳定度**，**算法的过程特征**



从时间复杂度来看：

简单选择排序，直接插入排序，和冒泡排序的时间复杂度为$O(n^2)$，且实现过程简单，但是直接插入排序和冒泡排序的最好情况下的复杂度可以达到$O(n)$，而简单选择排序则与序列的初始状态无关。希尔排序对较大规模的排序可以达到很高的效率，但是目前没有得出其精确的渐进时间。堆排序利用了堆的数据结构，可以在线性时间内完成搭建，且在$O(nlog_2(n))$内完成排序过程。快速排序基于分治的思想，虽然最坏情况是$O(n^2)$，但是平均性能是$O(nlog_2(n))$，在实际应用中优于其他排序算法。归并排序同样基于分治的思想，但是由于其切割子序列与初始序列无关，因此它的最好、最坏和平均复杂度均$O(nlog_2(n))$。



从空间复杂度看：

简单选择排序、插入排序、冒泡排序、希尔排序和堆排序都仅需要借助常数个辅助空间。快速排序在空间上只使用一个小的辅助栈，用于实现递归，平均情况下大小为$O(log_2(n))$，当然在最坏情况下可能会增长到 $O (n)$。2路归并排序在合并操作中需要借助较多的辅助空间用于元素复制，大小为 $O (n)$，虽然有方法能克服这个缺点，但其代价是算法会很复杂而且时间复杂度会增加。



从稳定性看：

插入排序、冒泡排序、归并排序和基数排序是稳定的排序方法，而简单选择排序、快速排序、希尔排序和堆排序都是不稳定的排序方法。平均时间复杂度$O(nlog_2(n))$的稳定排序算法只有归并排序，对于不稳定的排序方法，只要举出一个不稳定的实例即可。



从过程特征看：

采用不同的排序算法，在一次循环或几次循环后的排序结果可能是不同的，考研题中经常出现给出一个待排序的初始序列和已经部分排序的序列，问其采用何种排序算法。这就要对各类排序算法的过程特征十分熟悉，如冒泡排序和堆排序在每趟处理后都能产生当前的最大值或最小值，而快速排序一趟处理就能确定一个元素的最终位置等。



排序算法小结：

- 若 n 较小，可采用直接插入排序或简单选择排序。由于直接插入排序所需的记录移动次数较简单选择排序的多，因而当记录本身信息量较大时，用简单选择排序较好。若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序为宜。

- 若 n 较大，则应采用时间复杂度为 $O(nlog_2(n))$的排序方法：快速排序、堆排序或归并排序。快速排序被认为是目前基于比较的内部排序方法中最好的方法，当待排序的关键字随机分布时，快速排序的平均时间最短。堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况，这两种排序都是不稳定的。若要求排序稳定且时间复杂度为 $O(nlog_2(n))$，则可选用归并排序。从单个记录起进行两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。先利用直接插入排序求得较长的有序子文件，然后两两归并。直接插入排序是稳定的，
  因此改进后的归并排序仍是稳定的。
- 在基于比较的排序方法中，每次比较两个关键字的大小之后，仅出现两种可能的转移，因此可以用一棵二叉树来描述比较判定过程，由此可以证明：当文件的 n 个关键字随机分布时，任何借助于“比较”的排序算法，至少需要 $O(nlog_2(n))$的时间。
- 若 n 很大，记录的关键字位数较少且可以分解时，采用基数排序较好。
- 当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构。
