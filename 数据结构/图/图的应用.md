---
title: 图的应用
categories: 
- 数据结构
- 图
- 笔记
tags:
- 图
- 树
- 最小生成树
- 最短路径
- 拓扑排序
- 关键路径
---

# 图的应用

## 1.最小生成树

​	一个图的生成树包含图的所有顶点，并且只包含尽可能少的边。对于生成树来说，任意去掉一条边就会变成非连通图；增加一条边就会生成一个回路。

​	最小生成树的集合构成R，若T为R中边权值最小的生成树，则称T为图G的最小生成树（MST）

### 性质

1. 最小生成树不唯一。
2. 最小生成树的边的权值的和总是唯一的，虽然最小生成树唯一，但其对应的边的权值之和总是唯一的，而且是最小的。
3. **最小生成树的边数为顶点数-1**。

实现方式：贪心算法。

通用的最小生成树算法

1. 先设置树为空
2. 设置循环，循环条件是生成了一个树
3. 循环体内，找到最小代价边而且加入这条边之后不会形成回路
4. 条件满足就将这条边加入最小生成树

### Prim算法

初始时任取一个顶点放入集合T，不断选择和当前点集合的距离最小的结点，并将这条边和点加入，直到所有点都被并入T集合。

算法的简单实现如下：（示意表达）

```c
void Prim(G,T)
{
	T=NULL;//初始化空树
	U={w};//添加任一个顶点w
	while((V-U)!=NULL)//若树中不含全部顶点，设（u,v）能满足是跨越一个在U内一个在U外，而且权值最小的边
	{
		T=T+(u,v);//边归入树
		U=U+v;//顶点归入树
	}
}
```

### Kruskal算法

是一种按照权值的递增次序选择合适的边来构造最小生成树的方法。

Kruskal算法构造最小生成树的过程

1. 初始时只有N个顶点但是没有边。
2. 按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边，若这条边连接两个未被连通的连通分量，就加入树的集合，否则选取下一个权值更小的边。

算法的步骤如下：

1. 假设G=（V，E）是连通图，其最小生成树T=（U，Et)。
2. 初始化：U=V，Et=NULL。即每个顶点构成一棵独立的树，T此时是一个仅含|V|个顶点的森林。
3. 循环：按照G的边的权值递增顺序依次从E-Et中选择一条边，若这条边加入之后不构成回路，就加入Et, 否则丢弃，直到Et中含有N-1条边



## 2.最短路径

### 1.Dijkstra算法求单源最短路问题

在构造的过程中设置两个辅助数组：

- dist[ ]:记录从源点v0到其他各个点的最短路径长度，它的初态为：若从v0到vi有弧，则dist[i]为弧上的权值，否则设置dist[i]为无穷大。

- path[ ]:path[i]表示从源点到顶点i之间的最短的前驱节点。算法结束的时候可以从这个值追溯得到v0到顶点i的最短路径。

邻接矩阵内的值代表的是有向图中边的权值，如果不存在有向边<i,j>就置为无穷大。

#### Dijkstra算法的步骤如下：

1. 初始化：集合S初始化为{0}，把邻接矩阵的一行放入dist数组中。
2. 从顶点集合V-S中选出v_[j],满足dist[j]=Min{dist[i]|v_[i]属于V-S}，这就是选出的从v0选出的从v0出发的最短路径的终点，令S=S+{j}.
3. 修改从v0出发的最短路径的最短路径长度：如果满足两边长小于实际的长度，更新这个值。
4. 重复选点的操作，直到所有的顶点都包含在S中

显然Dijkstra也是基于贪心策略的。使用邻接矩阵和邻接表的时间复杂度为O（|V|^2^）



### 2.Floyd算法求各个顶点之间最短路的问题

使用n-1个方阵序列，如果每次新加入的节点能够让两个点之间的距离减小，就更新方正中对应的权值，没迭代一次多考虑一个节点，这样在进行n次迭代之后得到的最终权值矩阵就是最短路径长度的矩阵。

相当于按照每个顶点都执行了Dijstra算法，时间复杂度为O（|V|^3^）



## 3.有向无环图描述表达式

有向无环图 DAG图

​	描述含有公共子表达式的工具，通过共享表达式的方式实现相同表达式的存储空间节省的目的



## 4.拓扑排序

AOV网：如果用DAG图中有向边<Vi, Vj>表示活动Vi必须先于Vj这样的关系，就将这种有向图称为顶点表示活动的网络，记为AOV网。

**拓扑排序：**在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时称为该图的一个拓扑排序：

1. 每个顶点出现且仅出现一次。
2. 若顶点A在序列中排在B的前面，则在图中不存在从顶点B到顶点A的路径。

对一个AOV网进行拓扑排序的算法有很多，下面介绍比较常用的一种方法的步骤：

1. 从AOV网中选择一个没有前驱的顶点并输出。
2. 从网中删除该顶点和所有以它为起点的有向边。
3. 重复1和2步骤直到当前的AOV网为空或者当前网中不存在无前驱的顶点为止。后一种情况说明有向图中必定存在环。

拓扑排序算法的实现如下：

```c
bool TopologicalSort(Graph G)
{
	InitStack(S);			//初始化栈，存储入度为0的结点
	for(int i=0;i<G.vexnum;i++)
	{
		if(indegree[i]==0)
			Push(S,i);		//将所有入度为0的顶点进栈
	}
	int count=0;			//计数，记录当前已经输出的顶点数
	while(!IsEmpty(S))		//栈不空，则存在入度为0的顶点
	{
		Pop(S,i);			//栈顶元素出栈
		print[count++]=i;	//输出顶点i
		for(p=G.vertices[i].firstarc;p=p->nextarc){
		//将所有的i指向的顶点入读减一，并且将入度减为0的顶点压入栈S
		v=p->adjvex;
		if(!--indegree[v])
		{
			Push(S,v);		//入度为0，则入栈
		}
		}
	}
	if(count<G.vexnum)
	return false;			//排序失败，有向图中有回路
	else
	return true;			//拓扑排序成功
}
```

用同样的思想，可以将删除的节点更换为一个没有后继的结点，这样的排序方式叫做逆拓扑排序。

用拓扑排序算法处理AOV网时，应该注意的问题：

1. 入度为0的结点，没有前驱活动的或前驱活动已经完成的节点，工程可以从这个顶点所代表的工程继续。
2. 若一个顶点有着很多直接后继，那么拓扑排序的结果通常不唯一，但是如果每个顶点已经放在一个线性有序的序列中，有唯一的前驱和后继关系，那么结果就是唯一的。
3. 由于 AOV网中各个顶点的地位平等，每个顶点的编号都是人为的，因此可以按照拓扑排序的结果来重新编号，生成的AOV的新的临界矩阵，这样的矩阵可以是三角矩阵；但是对于一般的图来说，如果邻接矩阵是三角矩阵，那么就存在拓扑序列；反之则不一定成立。



## 5.关键路径

​	用边来表示活动的网络称为AOE网络，AOE网和AOV网都是有向无环图，不同之处在于它们的边和顶点所代表的含义是不同的，AOE网中的边有权值；而AOV网中的边无权值，仅仅表示顶点之间的前后关系。

​	AOE存在入度为0的结点称为源点，出度为0的结点称为汇点。在AOE网中，工程师可以并行执行的；有多个有向路径，只有当所有路径上的活动都完成才能说整个工程已经完成，具有最大路径长度的路径就称为**关键路径**。

​	求关键路径的算法步骤如下:

1. 从源点出发，令ve(源点)=0， 按照拓扑排序求其余顶点的最早发生时间ve（）。
2. 从汇点出发，令vl(汇点)=ve(汇点），按照逆拓扑排序求其余顶点的最迟发生时间vl（）。
3. 根据各个顶点的ve值求所有弧的最早开始时间e().
4. 根据各个顶点的vl值求所有弧的最迟开始时间l().
5. 求AOE网中所有活动的差额d(), 找出所有的d()=0的活动构成关键路径。
